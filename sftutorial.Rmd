---
title: "Spatial Mapping with the SF Package"
author: "Erin Franke and Vivian Powell"
output: 
  html_document:
    toc: true
    toc_depth: 2

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Learning Objectives

This learning guide will introduce to the [**sf: Simple Features for R**](https://cran.r-project.org/web/packages/sf/index.html) package. We will cover: \

- The basic notation of plotting with sf \
- How to make a chloropleth map \
- How to overlay and crop different shape files on a single map \
- How to join spatial data frames 
- How to aggregate points a desired spatial polygon (census tract, county, state, etc) \
- How to customize your sf map with labels and colors

# Concepts 

```{r}
library(tidyverse)
library(dplyr)
library(sf)
library(tidycensus)
library(USAboundaries) 
```

### A basic map (notation)

This section will cover the basics of creating and understanding point, line, and polygon maps with the sf package. 

#### Intro to vector data

It's important to understand what type of spatial data you're working with, and what your goals are for your map. Most spatial data takes the form of vector data, meaning it is made up of either points, lines, or polygons (or other geometries, in more complex situations, but for the sake of this tutorial we'll stick to the main three). For example, city locations are usually be represented with points, roads are represented with lines, and country, state, or county boundaries are represented with polygons. Each layer on your map will either be points, lines, or polygons, and you can layer these in the order that makes sense for your map. 

#### Understanding sf notation

Sf stands for "simple features" which is a standardized way to store and interpret spatial data. In R, the sf package is really nice because it integrates spatial operations with tidyverse notation and is pretty easy to learn and use.

In R, sf data are simply data frame objects or tibbles, with the addition of a "geometry" column. The geometry column contains all the spatial information that you need in order to make a map layer. You'll notice that the entries in the geometry column will tell you what type of data (point, line, or polygon) you're working with.

Let's load some data so we can look at the format.

#### Load the data

```{r}
mn_cities <- read_sf('shp_loc_pop_centers')
```
After running the code, open up the data frame in your environment panel. Notice that the "geometry" column contains "POINT" objects. The rest of the data is essentially just a regular data frame that we can use our normal functions on.

It's also good to know which coordinate reference system your data uses, because if you are layering multiple datasets, the CRS needs to be consistent. Common CRS include NAD83 (for the United States only) and WGS84 (global). You can convert between these if need be.

```{r}
st_crs(mn_cities)
```
Our MN cities data uses NAD83 / UTM zone 15 datums. Let's convert that to regular NAD83, which is more likely to match other data. We can do this using the st_transform function, and by looking up the number for the NAD83 CRS, which turned out to be 4269.

```{r}
mn_cities <- mn_cities %>%
st_transform(crs = 4269)

st_crs(mn_cities)
```


Now we know that if we wanted to add another layer to our map, we'd need to to be in NAD83 as well, or we'd need convert this data to a different CRS. Let's choose a map of MN counties to plot under our cities, so that we can see the shape of Minnesota. We can get these from the "USAboundaries" package.

```{r}
#load data
mn_counties <- us_counties(resolution = "high", states = "Minnesota")

#clean out duplicate column names so we can filter later
names_counties <- names(mn_counties)
names(mn_counties)[names_counties == 'state_name'] <- c("state_name1", "state_name2")

#check CRS
st_crs(mn_counties)
```
Our county data used the WGS84 coordinate reference system, so we need to convert it to NAD83 before we use it with our city data. The number for WGS84 is 4326, if we needed to go the other way.

```{r}
mn_counties <- mn_counties %>%
  st_transform(crs = 4269)

st_crs(mn_counties)
```

#### Constructing a basic map using ggplot

A basic map in sf consists of a ggplot() base and geom_sf() layers. Unlike with most ggplots, you don't need to include any aesthetics or data in the ggplot line. You'll specify the data and aesthetics separately for each geom_sf layer that you add.

The order in which you add layers matters! Think of it as building a map from the bottom up. The layers you have further down in your code will appear on top of the layers at the top of your code.

```{r}
ggplot() +
  geom_sf(data = mn_counties) +
  geom_sf(data = mn_cities)
```

#### Customizing your map

Okay, we have a basic map! Let's make that look nicer. Also, I'll filter so that we only have cities with populations over 5,000.

```{r}
ggplot() +
  geom_sf(data = mn_counties, fill = 'wheat', color = "tan") + #add our county layer
  geom_sf(data = mn_cities %>% filter(Population >= 5000), color = 'steelblue4') + #add our filtered city layer
  labs(title = "Minnesota Cities with Population >= 5,000") + #labels just as with a regular ggplot
  theme_classic() + #remove grey background
  theme(axis.line=element_blank(), #remove the axis lines
        axis.text.x=element_blank(), #remove the x-axis text (longitudes)
        axis.ticks.x=element_blank(), #remove the x-axis ticks
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

#### Color by population using aesthetics

We could also choose to color the cities by their population:

```{r}
ggplot() +
  geom_sf(data = mn_counties, fill = 'wheat', color = "tan") + 
  geom_sf(data = mn_cities %>% filter(Population >= 5000), mapping = aes(color = Population), alpha = 0.8)+ 
  scale_color_viridis_c() +
  labs(title = "Minnesota Cities with Population >= 5,000") + 
  theme_classic() + 
  theme(axis.line=element_blank(), 
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

#### Zooming in by filtering data

Can't see much there, so let's zoom in on the Twin Cities area by choosing only a few counties. We can simply filter the county data by name. You could also zoom by specifying xlim() or ylim() for your ggplot, if you know which coordinate system is being used. In this case you'd use longitude and latitude as your x and y limits respectively.

```{r}
ggplot() +
  geom_sf(data = mn_counties %>%
            filter(name %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott") ), fill = 'wheat', color = "tan") + 
  geom_sf(data = mn_cities %>% filter(Population >= 5000), mapping = aes(color = Population), alpha = 0.8)+ 
  scale_color_viridis_c() +
  labs(title = "Minnesota Cities with Population >= 5,000") + 
  theme_classic() + 
  theme(axis.line=element_blank(), 
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

#### Zooming in by cropping data

In order to see our area of interest we also need to crop the city data. You can use the st_crop function.
```{r}
cities_7countyarea <- st_crop(mn_cities,st_bbox(mn_counties %>% filter(name %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott"))))
```
```{r}
ggplot() +
  geom_sf(data = mn_counties %>%
            filter(name %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott") ), fill = 'wheat', color = "tan") + 
  geom_sf(data = cities_7countyarea %>% filter(Population >= 5000), mapping = aes(color = Population))+ 
  scale_color_viridis_c() +
  labs(title = "Minnesota Cities with Population >= 5,000") + 
  theme_classic() + 
  theme(axis.line=element_blank(), 
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

#### Conclusion
That's a basic intro to making maps with the sf package in ggplot! There are other ways to map, but this is an especially convenient and familiar one. We'll explain more about labeling and plot design tools later on in this guide.

### Chloropleth maps 

### Joining and aggregating spatial data

#### Load the data

This set of examples will use data on domestic and public drinking wells with at least one sample, which we collect below from the Minnesota Pollution Control Agency (MPCA). We will look at these drinking wells on the county level, so please download the *shapefile* folder from the [Minnesota Geospatial Commons](https://gisdata.mn.gov/dataset/bdry-counties-in-minnesota) site and change the file path below to fit your needs.

```{r}
# domestic and public drinking wells with at least one sample
stationList <- read_csv("https://services.pca.state.mn.us/api/v1/groundwater/monitoring-stations?stationType=Well&format=csv") %>%
  filter(stationPurpose %in% c("Domestic Drinking", "Public Drinking"), sampleCount>0) 

# county boundaries for minnesota
county_boundaries <- st_read("data/shp_bdry_counties_in_minnesota/mn_county_boundaries_500.shp")
```

#### Make sure CRS are consistent 

Before joining spatial data, we need to make sure that the data we are joining have consistent coordinate reference systems. For this dataset, we are using NAD83. It also important to check data missing a latitude and longitude. 

```{r}
# clean well data
station_points <- stationList %>% 
  filter(lat > 0, long <0) %>% # remove wells with a missing latitude and longitude
  st_as_sf(coords = c("long", "lat"), crs = "NAD83")

# check CRS of station_points: NAD83
st_crs(station_points)
st_crs(county_boundaries) # need to be transformed

# transform county boundaries to NAD83
county_boundaries <- st_transform(county_boundaries, crs = "NAD83")
```

#### Complete the join

Now that we have county boundaries, we can match each drinking well to its appropriate county using a spatial join. Both the `station_points` and `county_boundaries` datasets have a `geometry` column (POINT for the wells, POLYGON for the counties) and the `st_join()` matches to point to the right polygon. Now we know what county each well is located in. 

```{r}
joined <- st_join(station_points, county_boundaries) 
head(joined)
```

#### Aggregation 

Now we can count how many wells are in each station with a simple `group_by()` as shown below. 

```{r}
stations_per_county <- joined %>%
  st_drop_geometry() %>% #removes geometry - makes calculation more efficient 
  group_by(CTY_NAME) %>%
  count() 
head(stations_per_county)
```

Check out how many stations we have per county 

```{r}
# looks like the max is much higher than the 75% quantile
summary(stations_per_county$n)

# check for ourliers on the high side
stations_per_county %>%
  arrange(desc(n)) %>%
  head()

# make an indicator variable for the high well county
stations_per_county$high_wells <- "1,000+"
stations_per_county$high_wells[stations_per_county$n <= 1000] <- NA
```

Make the chloropleth map with aggregated data

```{r}
stations_per_county_geo <- county_boundaries %>% # shape file with geometry goes first
  left_join(stations_per_county, by = "CTY_NAME")
  
ggplot() +
  geom_sf(data= subset(stations_per_county_geo, n<1000), aes(fill=n)) + 
  scale_fill_gradientn(colours = c("lightcyan", "lightcyan2", "lightskyblue3", "lightskyblue4"))+
  geom_sf(data = subset(stations_per_county_geo, n>1000),aes(color=high_wells), fill = "dodgerblue4")+
  labs(fill = "Wells", color = "", title = "Number of domestic/public drinking wells by Minnesota county", subtitle= "with at least one MPCA sample since 1988")+
  theme_classic()+
  theme(axis.line = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        plot.title.position = "plot", 
        plot.title = element_text(size = 8), 
        plot.subtitle = element_text(size = 8))
```

### Crop and overlay shape files

With a map, we can overlay shape files (such as roads, rivers, and lakes) and crop and them to fit our area of interest.

Start by downloading a shape file that you are interested in. For example, search "Minnesota roads shape file". For this example, visit [this site](https://catalog.data.gov/dataset/tiger-line-shapefile-2019-state-minnesota-primary-and-secondary-roads-state-based-shapefile) and download the Shapefile Zip File. Load in the shapefile (adjusting the file path as needed) using `st_read()`.

```{r}
roads <- st_read("data/tl_2019_27_prisecroads")
```

Add the shape file to the plot from above using the code `geom_sf(data = roads, fill = "gray",color = "gray", lwd= 0.2)`.

```{r}
ggplot() +
  geom_sf(data= subset(stations_per_county_geo, n<1000), aes(fill=n)) + 
  scale_fill_gradientn(colours = c("lightcyan", "lightcyan2", "lightskyblue3", "lightskyblue4"))+
  geom_sf(data = subset(stations_per_county_geo, n>1000),aes(color=high_wells), fill = "dodgerblue4")+
  geom_sf(data = roads, fill = "gray",color = "gray", lwd= 0.2)+
  labs(fill = "Wells", color = "", title = "Number of domestic/public drinking wells by Minnesota county", subtitle= "with at least one MPCA sample since 1988")+
  theme_classic()+
  theme(axis.line = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        plot.title.position = "plot", 
        plot.title = element_text(size = 8), 
        plot.subtitle = element_text(size = 8))
```

The prior shapefile matches our map perfectly, but say we wanted to plot just the seven county metropolitan area with the following map. Doing this, we can't really see what we want. 

```{r}
stations_per_county_geo7 <- stations_per_county_geo %>%
  filter(CTY_NAME %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott"))

ggplot() +
  geom_sf(data= subset(stations_per_county_geo7, n<1000), aes(fill=n)) + 
  scale_fill_gradientn(colours = c("lightcyan", "lightcyan2", "lightskyblue3", "lightskyblue4"))+
  geom_sf(data = subset(stations_per_county_geo7, n>1000),aes(color=high_wells), fill = "dodgerblue4")+
  geom_sf(data = roads, fill = "gray",color = "gray", lwd= 0.2)+
  labs(fill = "Wells", color = "", title = "Number of domestic/public drinking wells by Minnesota county", subtitle= "with at least one MPCA sample since 1988")+
  theme_classic()+
  theme(axis.line = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        plot.title.position = "plot", 
        plot.title = element_text(size = 8), 
        plot.subtitle = element_text(size = 8))
```

We can fix this with `st_crop()` where we provide our area of interest. We can now more easily see the area we are interested in. 

```{r}
roads_sub <- st_crop(roads,st_bbox(county_boundaries %>% filter(CTY_NAME %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott"))))

ggplot() +
  geom_sf(data= subset(stations_per_county_geo7, n<1000), aes(fill=n)) + 
  scale_fill_gradientn(colours = c("lightcyan", "lightcyan2", "lightskyblue3", "lightskyblue4"))+
  geom_sf(data = subset(stations_per_county_geo7, n>1000),aes(color=high_wells), fill = "dodgerblue4")+
  geom_sf(data = roads_sub, fill = "gray",color = "gray", lwd= 0.2)+
  labs(fill = "Wells", color = "", title = "Number of domestic/public drinking wells by Minnesota county", subtitle= "with at least one MPCA sample since 1988")+
  theme_classic()+
  theme(axis.line = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        plot.title.position = "plot", 
        plot.title = element_text(size = 8), 
        plot.subtitle = element_text(size = 8))
```

### Customization

# Exercises 

The following exercises will use census tract `tidycensus` data for the Hennepin and Ramsey county. We provide several variables you can choose from in order to create maps that best fit your interest.

Load the data with the following code:

```{r}
census_api_key("f0d9e7b9eb0a91da1b9d33277cf20e264c19e197", install = TRUE, overwrite=TRUE)

census2020 <- get_acs(year = 2020, state = "MN", geography = "tract", variables = c(	
"B01003_001", "B19013_001", "B23006_023", "B25058_001", "B25107_001", "B25003_001", "B25003_002", "B25003_003", "B25077_001"), output = 'wide', geometry = TRUE) %>%
  filter(word(NAME, 4) %in% c("Ramsey", "Hennepin"))%>%
               mutate(tract = word(NAME, 3),
                      tract = str_remove(tract, ","),
                      county = word(NAME, 4)) %>%
               select(-NAME) %>%
               rename("population" = "B01003_001E", 
                      "medianIncome" = "B19013_001E", 
                      "bachelors" = "B23006_023E",
                      "medContractRent" = "B25058_001E", 
                      "tenureTotal" = "B25003_001E", 
                      "tenureOwned" = "B25003_002E", 
                      "tenureRented" = "B25003_003E",
                      "medianHomeValue"= "B25077_001E") %>%
  select(-contains("_"))

crashes <- read_csv("data/Pedestrian_and_Bike_Crash_Dataset__.csv") %>%
  filter(!is.na(Latitude), !is.na(Longitude))
```

### Exercise 1: A basic sf map

### Exercise 2: A choropleth map

### Exercise 3: Joining and aggregation

**Create a map of crashes per census tract in Ramsey county.** Hint: you will first have to transform the `crashes` data to have a point geometry using the code below. 

```{r}
crashes <- st_as_sf(crashes, coords = c("Longitude", "Latitude"), crs = "NAD83")
```

SOLUTION: 
```{r}
#check coordinates
st_crs(census2020)
st_crs(crashes)

crashes_per_tract <- st_join(crashes, census2020) %>%
  st_drop_geometry() %>% #removes geometry - makes calculation more efficient 
  group_by(tract) %>%
  count() 

crashes_per_tract_geo <- census2020 %>% # shape file with geometry goes first
  left_join(crashes_per_tract, by = "tract")
  
ggplot() +
  geom_sf(data= subset(crashes_per_tract_geo, n<1000), aes(fill=n)) + 
  scale_fill_gradientn(colours = c("lightcyan", "lightcyan2", "lightskyblue3", "lightskyblue4"))+
  geom_sf(data = subset(crashes_per_tract_geo, n>1000), fill = "dodgerblue4")+
  labs(fill = "Crashes", color = "", title = "Number of pedestrian crashes per census tract")+
  theme_classic()+
  theme(axis.line = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        plot.title.position = "plot", 
        plot.title = element_text(size = 8), 
        plot.subtitle = element_text(size = 8))
```


### Exercise 4: Adding layers

**Plot a variable of your choice for census tracts in Hennepin and Ramsey County and add roads to the map.**

SOLUTION

```{r}
roads_sub <- st_crop(roads,st_bbox(census2020))

ggplot() +
  geom_sf(data = census2020, aes(fill = population))+
  labs(fill = "Population", color = "", title = "Population per census tract in Hennepin and Ramsey County")+
  geom_sf(data= roads_sub, fill = "gray", color = "gray", lwd = 0.2)+
  scale_fill_gradientn(colours = c("lightcyan", "lightcyan2", "lightskyblue3", "lightskyblue4"))+
  theme_classic()+
  theme(axis.line = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        plot.title.position = "plot", 
        plot.title = element_text(size = 8), 
        plot.subtitle = element_text(size = 8))
```


